function nodeToXML(node, lvl) {
  var stack = [];
  var result= "";
  var tmp = [];
  var propertiesNum = Object.keys(node.properties || tmp).length;
  var childNum = Object.keys(node.children || tmp).length;

  //Block processing
  if (!node.isBlock) {
    stack.push("</" + node.type + ">\n");
    result += indent(lvl) + "<" + node.type + ">\n";
  } else {
    stack.push("</block>\n");
    result += indent(lvl) + '<block creationArguments=\"' + node.type + '">\n';
    if (node.specialData) {
      result += indent(lvl + 1) + '<specialData>\n' + indent(lvl + 1) + node.subBlocks[2].point + '\n' + indent(lvl + 1) + '</specialData>\n';
    }
}

  //Style processing
  if (node.subBlocks != undefined && Object.keys(node.subBlocks).length  > 0) {
    for (var i = 0; i < Object.keys(node.subBlocks).length; i++) {
      result+= nodeToXML(node.subBlocks[i], lvl + 1);
    }
  }

  //Properties processing
  if (propertiesNum > 0) {
    stack.push("</properties>\n");
    result += indent(lvl+1) + "<properties>\n";
    for (var s in node.properties) {
      result += indent(lvl+2) + "<" + s + ">" + node.properties[s] + "</" + s + ">\n";
    }
    result += indent(lvl+1) + stack.pop();
  }

  //Children processing
  if (childNum > 0) {
    stack.push("</children>\n");
    result += indent(lvl+1) + "<children>\n";
    for (var i = 0; i < childNum; i++) {
      if (node.type == "magazine" || node.type == "page" || node.type == "group") {
        result+= nodeToXML(node.children[i], lvl+2);
      }
    }
  }

  while (stack.length > 0) {
    result += indent(stack.length+lvl-1) + stack.pop();
  }
  return result;
}

function XMLToFile(text, path) {
  path += tree[0].name + ".xml";
  var t = [NSString stringWithFormat:@"%@", text];
  f = [NSString stringWithFormat:@"%@", path];
  return [t writeToFile:f atomically:true encoding:NSUTF8StringEncoding error:nil];
}
